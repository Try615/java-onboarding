### 문제 접근.  
*하나의 메소드에 하드 코딩으로 풀어도 무방한 문제지만, 시험 문제를 푸는게 아니라 개발 작업을 한다 생각하고 중복된 코드의 반복을 막아보자.*  
- cryptogram은 길이가 1 이상 1000 이하인 문자열이다. : 만약 이 문제를 완탐한다면 최대 1000!의 순회가 필요하다.
이 문제는 중첩되는 동일한 알파벳을 제거해나가는 문제다. 그렇다면 문자열의 문자를 하나씩 저장해나가다 마지막 저장한 문자와 들어오는 문자가 같은지 검증한다면 매번 문자열 전체를 순회할 필요가 없다. 이에 가장 적합한 구조는 스택(Stack)이다.  
최종적인 문자열은 스택을 하나씩 ```pop()```하여 ```StringBuilder```에 저장하고 ```reverse()```로 뒤집어서 도출한다.  
- cryptogram은 알파벳 소문자로만 이루어져 있다. : 이 제약 조건은 스택으로 풀어간다면 고려할 사항이 아닌 것 같다. 유의만 해두자.  



### 기능 목록
- [x] 스택 자료구조 생성  
암호문을 푸는 해독기 ```Decrpyt```클래스를 생성하고 ```Decrypt()```메소드 하나로 전체 동작을 수행하도록 구조 생성.  
- [x] 문자열을 순회하며 스택에 저장  
```decrypt()```에서 ```Decrypt```클래스의 필드인 ```stack```에 ```cryptogram```을 순회하며 문자로 나눠 저장  
- [x] 스택에 저장한 이전 문자와 입력할 문자가 동일할 시 둘 다 제거  
```decrypt()```에서 ```stack```의 ```peek()```메소드로 마지막 원소를 제거하지 않고 가져와 현재 입력할 문자와 비교. 같을 시 둘 다 제거, 다를 시 입력.  
*문자열을 순회하며 스택에 넣는 과정과 스택 문자 비교 과정을 나눌 시 스택을 사용하는 장점이 사라지므로 이 기능은 ```decrypt()```에서 함께 처리*  
- [x] 스택에 저장한 이전 문자와 입력할 문자가 다르다면 스택에 저장  
*위의 내용과 동일.*  
- [x] 최종 문자열 도출  
```Decrpyt```클래스의 필드인 StringBuilder 타입의 ```sb```에 저장 후 리턴.  

---  

## 🚀 기능 요구 사항

암호문을 좋아하는 괴짜 개발자 브라운이 이번에는 중복 문자를 이용한 새로운 암호를 만들었다. 예를 들어 "browoanoommnaon"이라는 암호문은 다음과 같은 순서로 해독할 수 있다.

1. "browoanoommnaon"
2. "browoannaon"
3. "browoaaon"
4. "browoon"
5. "brown"

임의의 문자열 cryptogram이 매개변수로 주어질 때, 연속하는 중복 문자들을 삭제한 결과를 return 하도록 solution 메서드를 완성하라.

### 제한사항

- cryptogram은 길이가 1 이상 1000 이하인 문자열이다.
- cryptogram은 알파벳 소문자로만 이루어져 있다.

### 실행 결과 예시

| cryptogram | result |
| --- | --- |
| "browoanoommnaon" | "brown" |
| "zyelleyz" | "" |  



